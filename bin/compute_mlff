#! /usr/bin/env python3

from pathlib import Path
from typing import List

import jax.numpy as jnp
import numpy as np
import typer
import xarray as xr
from ase.io import read
from ase.units import GPa
from glp import atoms_to_system
from glp.calculators import supercell
from jax import jit
from mlff.mdx import MLFFPotential
from rich import print as echo
from rich.progress import track
from tdeptools.cli.tdep_parse_output import dimensions, keys, write_infiles, write_meta

app = typer.Typer(pretty_exceptions_show_locals=False)


@app.command()
def main(
    files: List[Path],
    folder_model: str = "module",
    outfile: str = "predictions.nc",
    skin: float = 1.0,
    tdep: bool = False,
    format: str = "aims",
):
    """Convert trajectory files to MLFF input as npz file"""
    echo(files)

    # read first file and create atoms
    atoms = read(files[0], format=format)
    echo(f"... System: {atoms}")

    potential = MLFFPotential.create_from_ckpt_dir(
        folder_model, add_shift=True, dtype=jnp.float64
    )

    calculator, state = supercell.calculator(
        potential, atoms_to_system(atoms), n_replicas=1, skin=skin
    )
    calculate = jit(calculator.calculate)

    # predict
    n_atoms = len(atoms)
    n_samples = len(files)

    rows = []
    for ii, file in enumerate(track(files)):
        atoms = read(file, format=format)

        predictions, state = calculate(atoms_to_system(atoms), state)
        assert not state.overflow, "FIXME"

        s = predictions["stress"] / atoms.get_volume()
        if tdep:
            s /= GPa  # TDEP wants GPa
            _stress = np.array([s[0, 0], s[1, 1], s[2, 2], s[2, 1], s[2, 0], s[1, 0]])
            _pressure = np.mean(_stress[:3])
        else:
            _stress = s
            _pressure = np.trace(s).mean()

        row = {
            keys.cell: np.asarray(atoms.cell),
            keys.natoms: len(atoms),
            keys.volume: atoms.get_volume(),
            keys.positions_cartesian: atoms.positions,
            keys.positions: atoms.get_scaled_positions(),
            keys.forces: predictions["forces"],
            keys.energy_total: predictions["energy"],
            keys.energy_kinetic: 0.0,
            keys.energy_potential: predictions["energy"],
            keys.temperature: 0.0,
            keys.stress: _stress,
            keys.pressure: _pressure,
        }

        rows.append(row)

    if tdep:
        write_infiles(rows)
        write_meta(n_atoms=n_atoms, n_samples=n_samples)
    else:
        # rewrite data as DataArrays
        _keys = rows[0].keys()

        arrays = {}
        for k in _keys:
            array = np.concatenate([[row[k] for row in rows]], axis=0)
            dims = ["time"]
            if k in dimensions:
                dims.extend(dimensions[k])
            arrays[k] = xr.DataArray(array, name=k, dims=dims)

        ds = xr.Dataset(arrays)

        echo(ds)

        echo(f"... save data to {outfile}")
        ds.to_netcdf(outfile)


if __name__ == "__main__":
    app()
